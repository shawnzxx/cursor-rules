# 单元测试创建指南

本文档提供了在 Tyche 项目中创建高质量单元测试的完整指南。

## 基本测试结构

### 1. 测试文件命名

- 测试文件必须以 `_test.go` 结尾
- 与被测试的源文件同目录：`filename.go` -> `filename_test.go`

### 2. 基本测试模板

```go
package packagename

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestFunctionName(t *testing.T) {
    t.Parallel() // 对于不修改全局状态的测试

    tests := []struct {
        name           string
        input          InputType
        expectedOutput OutputType
        expectedError  string
    }{
        {
            name:           "success_case",
            input:          InputType{/* test data */},
            expectedOutput: OutputType{/* expected result */},
            expectedError:  "",
        },
        {
            name:          "error_case",
            input:         InputType{/* test data */},
            expectedError: "expected error message",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // 对于不修改全局状态的子测试

            // Given/When/Then 模式
            // Given: 设置测试数据

            // When: 执行被测试的函数
            result, err := FunctionName(tt.input)

            // Then: 验证结果
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)
        })
    }
}
```

## 并发测试处理规则 🚨 重要

### 1. 对于不修改全局状态的测试

**添加 `t.Parallel()` 以提高测试执行速度**

```go
func TestPureFunction(t *testing.T) {
    t.Parallel() // ✅ 安全，因为不修改全局状态

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // ✅ 子测试也可以并行

            // 测试逻辑...
        })
    }
}
```

### 2. 对于修改全局变量的测试

**不使用 `t.Parallel()` 以避免竞态条件**

```go
var globalVar = "initial"

func TestFunctionModifyingGlobal(t *testing.T) {
    // ❌ 不使用 t.Parallel() - 修改全局变量会产生竞态条件

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // ❌ 子测试也不使用 t.Parallel()
            // 不使用 t.Parallel() 因为修改全局变量会产生竞态条件

            // 保存原始值
            original := globalVar
            defer func() {
                globalVar = original // 恢复原始值
            }()

            // 修改全局变量进行测试
            globalVar = tt.testValue

            // 测试逻辑...
        })
    }
}
```

### 3. 对于共享资源初始化

**使用 `sync.Once` 确保线程安全的单次初始化**

```go
import "sync"

var (
    sharedResource *SomeResource
    once          sync.Once
)

func initializeSharedResource() {
    once.Do(func() {
        sharedResource = &SomeResource{
            // 初始化逻辑
        }
    })
}

func TestWithSharedResource(t *testing.T) {
    t.Parallel() // ✅ 安全，因为使用了 sync.Once 保护

    initializeSharedResource()
    // 使用 sharedResource 进行测试
}
```

### 4. 对于环境变量修改

**不使用 `t.Parallel()` 并添加适当的清理机制**

```go
func TestWithEnvironmentVariable(t *testing.T) {
    // ❌ 不使用 t.Parallel() - 修改环境变量会产生竞态条件

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // ❌ 不使用 t.Parallel() 因为修改环境变量会产生竞态条件

            // 保存原始环境变量
            originalEnv := os.Getenv("TEST_ENV")
            defer func() {
                if originalEnv == "" {
                    os.Unsetenv("TEST_ENV")
                } else {
                    os.Setenv("TEST_ENV", originalEnv)
                }
            }()

            // 设置测试环境变量
            err := os.Setenv("TEST_ENV", tt.envValue)
            require.NoError(t, err)

            // 测试逻辑...
        })
    }
}
```

## 测试数据准备

### 1. 使用表驱动测试

```go
tests := []struct {
    name           string
    input          InputType
    mockSetup      func(*MockDependency)
    expectedOutput OutputType
    expectedError  string
}{
    {
        name: "success_case",
        input: InputType{
            Field1: "value1",
            Field2: 123,
        },
        mockSetup: func(mock *MockDependency) {
            mock.On("Method", mock.Anything).Return(expectedResult, nil)
        },
        expectedOutput: OutputType{
            Field: "expected",
        },
    },
}
```

### 2. Mock 设置

```go
func TestWithMocks(t *testing.T) {
    t.Parallel()

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            // 创建 mock
            mockDep := NewMockDependency(t)

            // 设置 mock 期望
            if tt.mockSetup != nil {
                tt.mockSetup(mockDep)
            }

            // 创建被测试对象
            service := NewService(mockDep)

            // 执行测试
            result, err := service.Method(tt.input)

            // 验证结果
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)

            // 验证 mock 调用
            mockDep.AssertExpectations(t)
        })
    }
}
```

## 错误处理测试

### 1. 确保每个 'if err != nil' 分支都有对应的测试用例

```go
// 被测试的函数
func ProcessData(input string) (string, error) {
    if input == "" {
        return "", errors.New("input cannot be empty") // ← 需要测试用例
    }

    result, err := externalCall(input)
    if err != nil {
        return "", fmt.Errorf("external call failed: %w", err) // ← 需要测试用例
    }

    return result, nil
}

// 测试用例必须覆盖所有错误分支
tests := []struct {
    name          string
    input         string
    mockSetup     func()
    expectedError string
}{
    {
        name:          "empty_input_error",
        input:         "",
        expectedError: "input cannot be empty",
    },
    {
        name:  "external_call_error",
        input: "valid_input",
        mockSetup: func() {
            // 设置 mock 返回错误
        },
        expectedError: "external call failed: mock error",
    },
    {
        name:  "success_case",
        input: "valid_input",
        mockSetup: func() {
            // 设置 mock 返回成功
        },
    },
}
```

## 测试覆盖率要求

### 1. 最低覆盖率要求

- **业务逻辑文件至少 80% 覆盖率**
- **排除 mock\_\*.go 文件** - 这些是自动生成的 mock 文件

### 2. 覆盖率检查命令

```bash
# 整体覆盖率
go test -cover ./... -coverprofile=coverage.out

# 仅业务逻辑覆盖率（排除 mock 文件）
go test -cover ./... -coverprofile=coverage.out && go tool cover -func=coverage.out | grep -v mock_

# 检查特定业务逻辑文件
go tool cover -func=coverage.out | grep "\.go:" | grep -v mock_

# 生成 HTML 覆盖率报告
go tool cover -html=coverage.out
```

## 项目特定规则

### 1. 使用宽松的 SQL 匹配模式

对于 SQL 测试，使用宽松的正则表达式而不是严格匹配：

```go
// ✅ 推荐：宽松模式
mock.ExpectQuery("SELECT.*FROM.*table").WillReturnRows(rows)

// ❌ 避免：过于严格的匹配
mock.ExpectQuery("SELECT id, name FROM table WHERE id = ?").WillReturnRows(rows)
```

### 2. 遵循 Given/When/Then 模式

```go
t.Run("test_case", func(t *testing.T) {
    t.Parallel()

    // Given: 准备测试数据和 mock
    input := TestInput{Field: "value"}
    mockDep := NewMockDependency(t)
    mockDep.On("Method", mock.Anything).Return(expected, nil)

    // When: 执行被测试的函数
    result, err := functionUnderTest(input, mockDep)

    // Then: 验证结果
    require.NoError(t, err)
    assert.Equal(t, expected, result)
    mockDep.AssertExpectations(t)
})
```

### 3. 测试文件组织

- 每个源文件对应一个测试文件
- 测试函数名称应该清晰描述被测试的功能
- 使用描述性的测试用例名称

## 常见陷阱和最佳实践

### ❌ 避免的做法

- 在修改全局变量的测试中使用 `t.Parallel()`
- 在修改环境变量的测试中使用 `t.Parallel()`
- 忽略错误分支的测试覆盖
- 使用过于严格的 SQL 匹配模式
- 忘记清理测试后的状态

### ✅ 推荐的做法

- 对纯函数使用 `t.Parallel()` 提高测试速度
- 使用 `sync.Once` 保护共享资源初始化
- 为每个错误分支编写测试用例
- 使用表驱动测试提高可维护性
- 在测试后恢复全局状态
- 使用 Given/When/Then 模式组织测试逻辑
