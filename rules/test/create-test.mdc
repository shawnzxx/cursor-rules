---
globs: *_test.go
alwaysApply: false
---

# 单元测试创建指南

本文档提供了在 ${PROJECT_NAME} 项目中创建高质量单元测试的完整指南。

## 基本测试结构

### 1. 测试文件命名

- 测试文件必须以 `_test.go` 结尾
- 与被测试的源文件同目录：`filename.go` -> `filename_test.go`

### 2. 基本测试模板

```go
package packagename

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestFunctionName(t *testing.T) {
    t.Parallel() // 使用 t.Parallel() 如果测试不修改全局状态

    tests := []struct {
        name           string
        input          InputType
        expectedOutput OutputType
        expectedError  string
    }{
        {
            name:           "success_case",
            input:          InputType{/* test data */},
            expectedOutput: OutputType{/* expected result */},
            expectedError:  "",
        },
        {
            name:          "error_case",
            input:         InputType{/* test data */},
            expectedError: "expected error message",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // 使用 t.Parallel() 如果子测试不修改全局状态

            // Given/When/Then 模式
            // Given: 设置测试数据

            // When: 执行被测试的函数
            result, err := FunctionName(tt.input)

            // Then: 验证结果
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)
        })
    }
}
```

## 断言选择指南 🎯

### 基本原则

- **新测试**：默认使用 `assert.*` 系列
- **现有测试**：保持现有的 `require.*` 调用不变（避免不必要的修改）
- **错误检查**：对于独立的错误检查，优先使用 `assert.NoError(t, err)` 或 `assert.EqualError(t, err, "expected message")`
- **CI/CD 环境**：`assert.*` 和 `require.*` 都会在测试失败时停止 CI/CD，但 `assert.*` 提供更多诊断信息

在绝大多数情况下，特别是在 **CI/CD 环境**中，推荐使用 `assert.*` 系列断言：

```go
func TestWallet(t *testing.T) {
    wallet := CreateWallet()

    // ✅ 推荐：使用 assert - 收集所有失败信息
    assert.NotNil(t, wallet)
    assert.Equal(t, 100, wallet.Balance)
    assert.Equal(t, "active", wallet.Status)
    assert.True(t, wallet.IsValid())
    // 即使前面的断言失败，所有断言都会执行，提供完整的错误信息
}
```

**为什么推荐 `assert`：**

- 📊 **更好的错误诊断**：收集所有失败，一次看到所有问题
- 🚀 **提高调试效率**：一次性修复所有错误，而不是一个一个来
- ⚡ **CI/CD 行为一致**：任何失败都会导致 `make test` 返回非零退出码，停止 CI/CD pipeline
- 🔍 **完整的测试报告**：在 Jenkins 日志中能看到所有失败的断言

#### 仅在依赖场景使用 `require.*`

只在**后续断言强烈依赖前面结果**时使用 `require.*`：

```go
func TestWalletOperations(t *testing.T) {
    wallet := CreateWallet()

    // ✅ 合适使用 require：如果 wallet 为 nil，后续操作都没意义
    require.NotNil(t, wallet)

    // 这些断言相互独立，使用 assert
    assert.Equal(t, 100, wallet.Balance)
    assert.Equal(t, "active", wallet.Status)
    assert.True(t, wallet.IsValid())

    // 另一个依赖场景
    err := wallet.Debit(50)
    require.NoError(t, err) // 如果这里失败，后续余额检查没意义

    assert.Equal(t, 50, wallet.Balance)
}
```

#### 对比示例

```go
// ❌ 使用 require - 只看到第一个问题
func TestWalletWithRequire(t *testing.T) {
    wallet := CreateWallet()
    require.NotNil(t, wallet)        // 如果失败，测试停止
    require.Equal(t, 100, wallet.Balance)    // 不会执行
    require.Equal(t, "active", wallet.Status) // 不会执行
    require.True(t, wallet.IsValid())        // 不会执行
    // 结果：只知道第一个错误，需要多次修复-测试循环
}

// ✅ 使用 assert - 看到所有问题
func TestWalletWithAssert(t *testing.T) {
    wallet := CreateWallet()
    assert.NotNil(t, wallet)         // 失败但继续
    assert.Equal(t, 100, wallet.Balance)     // 也会检查
    assert.Equal(t, "active", wallet.Status) // 也会检查
    assert.True(t, wallet.IsValid())         // 也会检查
    // 结果：一次看到所有错误，一次性修复所有问题
}
```

## 测试用例规范

### 1. 对于不修改全局状态的测试

**添加 `t.Parallel()` 以提高测试执行速度**

```go
func TestPureFunction(t *testing.T) {
    t.Parallel() // ✅ 安全，因为不修改全局状态

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // ✅ 子测试也可以并行

            // 测试逻辑...
        })
    }
}
```

### 2. 对于修改全局变量的测试

**不使用 `t.Parallel()` 以避免竞态条件**

```go
var globalVar = "initial"

func TestFunctionModifyingGlobal(t *testing.T) {
    // ❌ 不使用 t.Parallel() - 修改全局变量会产生竞态条件

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // ❌ 子测试也不使用 t.Parallel()
            // 不使用 t.Parallel() 因为修改全局变量会产生竞态条件

            // 保存原始值
            original := globalVar
            defer func() {
                globalVar = original // 恢复原始值
            }()

            // 修改全局变量进行测试
            globalVar = tt.testValue

            // 测试逻辑...
        })
    }
}
```

### 3. 对于共享资源初始化

**使用 `sync.Once` 确保线程安全的单次初始化**

```go
import "sync"

var (
    sharedResource *SomeResource
    once          sync.Once
)

func initializeSharedResource() {
    once.Do(func() {
        sharedResource = &SomeResource{
            // 初始化逻辑
        }
    })
}

func TestWithSharedResource(t *testing.T) {
    t.Parallel() // ✅ 安全，因为使用了 sync.Once 保护

    initializeSharedResource()
    // 使用 sharedResource 进行测试
}
```

### 4. 对于环境变量修改

**不使用 `t.Parallel()` 并添加适当的清理机制**

```go
func TestWithEnvironmentVariable(t *testing.T) {
    // ❌ 不使用 t.Parallel() - 修改环境变量会产生竞态条件

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // ❌ 不使用 t.Parallel() 因为修改环境变量会产生竞态条件

            // 保存原始环境变量
            originalEnv := os.Getenv("TEST_ENV")
            defer func() {
                if originalEnv == "" {
                    os.Unsetenv("TEST_ENV")
                } else {
                    os.Setenv("TEST_ENV", originalEnv)
                }
            }()

            // 设置测试环境变量
            err := os.Setenv("TEST_ENV", tt.envValue)
            require.NoError(t, err)

            // 测试逻辑...
        })
    }
}
```

## 测试数据准备

### 1. 使用表驱动测试

```go
tests := []struct {
    name           string
    input          InputType
    mockSetup      func(*MockDependency)
    expectedOutput OutputType
    expectedError  string
}{
    {
        name: "success_case",
        input: InputType{
            Field1: "value1",
            Field2: 123,
        },
        mockSetup: func(mock *MockDependency) {
            mock.On("Method", mock.Anything).Return(expectedResult, nil)
        },
        expectedOutput: OutputType{
            Field: "expected",
        },
    },
}
```

### 2. Mock 设置

```go
func TestWithMocks(t *testing.T) {
    t.Parallel()

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            // 创建 mock
            mockDep := NewMockDependency(t)

            // 设置 mock 期望
            if tt.mockSetup != nil {
                tt.mockSetup(mockDep)
            }

            // 创建被测试对象
            service := NewService(mockDep)

            // 执行测试
            result, err := service.Method(tt.input)

            // 验证结果
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)

            // 验证 mock 调用
            mockDep.AssertExpectations(t)
        })
    }
}
```

## 错误处理测试

### 1. 确保每个 'if err != nil' 分支都有对应的测试用例

```go
// 被测试的函数
func ProcessData(input string) (string, error) {
    if input == "" {
        return "", errors.New("input cannot be empty") // ← 需要测试用例
    }

    result, err := externalCall(input)
    if err != nil {
        return "", fmt.Errorf("external call failed: %w", err) // ← 需要测试用例
    }

    return result, nil
}

// 测试用例必须覆盖所有错误分支
tests := []struct {
    name          string
    input         string
    mockSetup     func()
    expectedError string
}{
    {
        name:          "empty_input_error",
        input:         "",
        expectedError: "input cannot be empty",
    },
    {
        name:  "external_call_error",
        input: "valid_input",
        mockSetup: func() {
            // 设置 mock 返回错误
        },
        expectedError: "external call failed: mock error",
    },
    {
        name:  "success_case",
        input: "valid_input",
        mockSetup: func() {
            // 设置 mock 返回成功
        },
    },
}
```

## 测试覆盖率要求

### 1. 最低覆盖率要求

- **业务逻辑文件至少 80% 覆盖率**
- **排除 mock\_\*.go 文件** - 这些是自动生成的 mock 文件

### 2. 覆盖率检查命令

```bash
# 整体覆盖率
go test -cover ./... -coverprofile=coverage.out

# 仅业务逻辑覆盖率（排除 mock 文件）
go test -cover ./... -coverprofile=coverage.out && go tool cover -func=coverage.out | grep -v mock_

# 检查特定业务逻辑文件
go tool cover -func=coverage.out | grep "\.go:" | grep -v mock_

# 生成 HTML 覆盖率报告
go tool cover -html=coverage.out
```

## 项目特定规则

### 1. 使用宽松的 SQL 匹配模式

对于 SQL 测试，使用宽松的正则表达式而不是严格匹配：

```go
// ✅ 推荐：宽松模式
mock.ExpectQuery("SELECT.*FROM.*table").WillReturnRows(rows)

// ❌ 避免：过于严格的匹配
mock.ExpectQuery("SELECT id, name FROM table WHERE id = ?").WillReturnRows(rows)
```

### 2. 遵循 Given/When/Then 模式

```go
t.Run("test_case", func(t *testing.T) {
    t.Parallel()

    // Given: 准备测试数据和 mock
    input := TestInput{Field: "value"}
    mockDep := NewMockDependency(t)
    mockDep.On("Method", mock.Anything).Return(expected, nil)

    // When: 执行被测试的函数
    result, err := functionUnderTest(input, mockDep)

    // Then: 验证结果
    require.NoError(t, err)
    assert.Equal(t, expected, result)
    mockDep.AssertExpectations(t)
})
```

### 3. 测试文件组织

- 每个源文件对应一个测试文件
- 测试函数名称应该清晰描述被测试的功能
- 使用描述性的测试用例名称

### Interface Nil 处理方式

#### 问题：Go Interface 的 nil 陷阱

当将 `nil` 具体类型指针传递给接口参数时，接口不会是 `nil`。这会导致 `interface == nil` 检查失败。

#### 错误示例

```go
func TestWithNilInterface_Wrong(t *testing.T) {
    var mockCacher *MockCacher = nil  // nil 具体类型

    // ❌ 错误：传递 nil 具体类型给接口参数
    business := NewBusiness(storer, mockCacher)

    // 这会失败，因为 business.cacher != nil
    // (接口包含 nil *MockCacher，不是 nil 接口)
    result, err := business.RefreshCache(ctx)
}
```

#### ✅ 正确处理方法

```go
func TestWithNilInterface_Correct(t *testing.T) {
    var mockCacher *MockCacher = nil

    // ✅ 正确：显式创建 nil 接口
    var cacherInterface Cacher  // nil 接口
    if mockCacher != nil {
        cacherInterface = mockCacher
    }

    business := NewBusiness(storer, cacherInterface)

    // 现在 business.cacher == nil 检查会正确工作
    result, err := business.RefreshCache(ctx)
}
```

#### 实际案例：RefreshCache 测试修复

```go
// 修复前的错误测试
for name, tc := range tcs {
    t.Run(name, func(t *testing.T) {
        mockStorer := &MockStorer{}
        var mockCacher *MockCacher

        if name == "no_cacher_configured" {
            mockCacher = nil  // ❌ 这是 nil 具体类型，不是 nil 接口
        } else {
            mockCacher = &MockCacher{}
        }

        // ❌ 错误：传递可能是 nil 具体类型的值给接口参数
        business := NewBusiness(mockStorer, mockCacher)
    })
}

// 修复后的正确测试
for name, tc := range tcs {
    t.Run(name, func(t *testing.T) {
        mockStorer := &MockStorer{}
        var mockCacher *MockCacher

        if name == "no_cacher_configured" {
            mockCacher = nil
        } else {
            mockCacher = &MockCacher{}
        }

        tc.mockSetup(mockStorer, mockCacher)

        // ✅ 正确：显式处理 nil 接口
        var cacherInterface Cacher
        if mockCacher != nil {
            cacherInterface = mockCacher
        }
        // 如果 mockCacher 是 nil，cacherInterface 保持 nil 接口

        business := NewBusiness(mockStorer, cacherInterface)
    })
}
```

#### 关键原理

在 Go 中，接口只有在**类型和值都为 nil** 时才为 `nil`：

```go
var i interface{} = (*MyType)(nil)  // 接口不为 nil！
fmt.Println(i == nil)               // false

var i interface{} = nil             // 接口为 nil
fmt.Println(i == nil)               // true
```

### 最佳实践

1. **明确区分 nil 具体类型和 nil 接口**
2. **测试中需要 nil 接口时，显式处理转换**
3. **避免直接将可能为 nil 的具体类型变量传递给接口参数**

## 常见陷阱和最佳实践

### ❌ 避免的做法

- 在修改全局变量的测试中使用 `t.Parallel()`
- 在修改环境变量的测试中使用 `t.Parallel()`
- 忽略错误分支的测试覆盖
- 使用过于严格的 SQL 匹配模式
- 忘记清理测试后的状态
- **直接将 nil 具体类型传递给接口参数**

### ✅ 推荐的做法

- 对纯函数使用 `t.Parallel()` 提高测试速度
- 使用 `sync.Once` 保护共享资源初始化
- 为每个错误分支编写测试用例
- 使用表驱动测试提高可维护性
- 在测试后恢复全局状态
- 使用 Given/When/Then 模式组织测试逻辑
- **正确处理接口的 nil 值转换**
