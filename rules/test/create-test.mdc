# å•å…ƒæµ‹è¯•åˆ›å»ºæŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†åœ¨ Tyche é¡¹ç›®ä¸­åˆ›å»ºé«˜è´¨é‡å•å…ƒæµ‹è¯•çš„å®Œæ•´æŒ‡å—ã€‚

## åŸºæœ¬æµ‹è¯•ç»“æ„

### 1. æµ‹è¯•æ–‡ä»¶å‘½å

- æµ‹è¯•æ–‡ä»¶å¿…é¡»ä»¥ `_test.go` ç»“å°¾
- ä¸è¢«æµ‹è¯•çš„æºæ–‡ä»¶åŒç›®å½•ï¼š`filename.go` -> `filename_test.go`

### 2. åŸºæœ¬æµ‹è¯•æ¨¡æ¿

```go
package packagename

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestFunctionName(t *testing.T) {
    t.Parallel() // å¯¹äºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€çš„æµ‹è¯•

    tests := []struct {
        name           string
        input          InputType
        expectedOutput OutputType
        expectedError  string
    }{
        {
            name:           "success_case",
            input:          InputType{/* test data */},
            expectedOutput: OutputType{/* expected result */},
            expectedError:  "",
        },
        {
            name:          "error_case",
            input:         InputType{/* test data */},
            expectedError: "expected error message",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // å¯¹äºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€çš„å­æµ‹è¯•

            // Given/When/Then æ¨¡å¼
            // Given: è®¾ç½®æµ‹è¯•æ•°æ®

            // When: æ‰§è¡Œè¢«æµ‹è¯•çš„å‡½æ•°
            result, err := FunctionName(tt.input)

            // Then: éªŒè¯ç»“æœ
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)
        })
    }
}
```

## å¹¶å‘æµ‹è¯•å¤„ç†è§„åˆ™ ğŸš¨ é‡è¦

### 1. å¯¹äºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€çš„æµ‹è¯•

**æ·»åŠ  `t.Parallel()` ä»¥æé«˜æµ‹è¯•æ‰§è¡Œé€Ÿåº¦**

```go
func TestPureFunction(t *testing.T) {
    t.Parallel() // âœ… å®‰å…¨ï¼Œå› ä¸ºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // âœ… å­æµ‹è¯•ä¹Ÿå¯ä»¥å¹¶è¡Œ

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

### 2. å¯¹äºä¿®æ”¹å…¨å±€å˜é‡çš„æµ‹è¯•

**ä¸ä½¿ç”¨ `t.Parallel()` ä»¥é¿å…ç«æ€æ¡ä»¶**

```go
var globalVar = "initial"

func TestFunctionModifyingGlobal(t *testing.T) {
    // âŒ ä¸ä½¿ç”¨ t.Parallel() - ä¿®æ”¹å…¨å±€å˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // âŒ å­æµ‹è¯•ä¹Ÿä¸ä½¿ç”¨ t.Parallel()
            // ä¸ä½¿ç”¨ t.Parallel() å› ä¸ºä¿®æ”¹å…¨å±€å˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

            // ä¿å­˜åŸå§‹å€¼
            original := globalVar
            defer func() {
                globalVar = original // æ¢å¤åŸå§‹å€¼
            }()

            // ä¿®æ”¹å…¨å±€å˜é‡è¿›è¡Œæµ‹è¯•
            globalVar = tt.testValue

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

### 3. å¯¹äºå…±äº«èµ„æºåˆå§‹åŒ–

**ä½¿ç”¨ `sync.Once` ç¡®ä¿çº¿ç¨‹å®‰å…¨çš„å•æ¬¡åˆå§‹åŒ–**

```go
import "sync"

var (
    sharedResource *SomeResource
    once          sync.Once
)

func initializeSharedResource() {
    once.Do(func() {
        sharedResource = &SomeResource{
            // åˆå§‹åŒ–é€»è¾‘
        }
    })
}

func TestWithSharedResource(t *testing.T) {
    t.Parallel() // âœ… å®‰å…¨ï¼Œå› ä¸ºä½¿ç”¨äº† sync.Once ä¿æŠ¤

    initializeSharedResource()
    // ä½¿ç”¨ sharedResource è¿›è¡Œæµ‹è¯•
}
```

### 4. å¯¹äºç¯å¢ƒå˜é‡ä¿®æ”¹

**ä¸ä½¿ç”¨ `t.Parallel()` å¹¶æ·»åŠ é€‚å½“çš„æ¸…ç†æœºåˆ¶**

```go
func TestWithEnvironmentVariable(t *testing.T) {
    // âŒ ä¸ä½¿ç”¨ t.Parallel() - ä¿®æ”¹ç¯å¢ƒå˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // âŒ ä¸ä½¿ç”¨ t.Parallel() å› ä¸ºä¿®æ”¹ç¯å¢ƒå˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

            // ä¿å­˜åŸå§‹ç¯å¢ƒå˜é‡
            originalEnv := os.Getenv("TEST_ENV")
            defer func() {
                if originalEnv == "" {
                    os.Unsetenv("TEST_ENV")
                } else {
                    os.Setenv("TEST_ENV", originalEnv)
                }
            }()

            // è®¾ç½®æµ‹è¯•ç¯å¢ƒå˜é‡
            err := os.Setenv("TEST_ENV", tt.envValue)
            require.NoError(t, err)

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

## æµ‹è¯•æ•°æ®å‡†å¤‡

### 1. ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•

```go
tests := []struct {
    name           string
    input          InputType
    mockSetup      func(*MockDependency)
    expectedOutput OutputType
    expectedError  string
}{
    {
        name: "success_case",
        input: InputType{
            Field1: "value1",
            Field2: 123,
        },
        mockSetup: func(mock *MockDependency) {
            mock.On("Method", mock.Anything).Return(expectedResult, nil)
        },
        expectedOutput: OutputType{
            Field: "expected",
        },
    },
}
```

### 2. Mock è®¾ç½®

```go
func TestWithMocks(t *testing.T) {
    t.Parallel()

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            // åˆ›å»º mock
            mockDep := NewMockDependency(t)

            // è®¾ç½® mock æœŸæœ›
            if tt.mockSetup != nil {
                tt.mockSetup(mockDep)
            }

            // åˆ›å»ºè¢«æµ‹è¯•å¯¹è±¡
            service := NewService(mockDep)

            // æ‰§è¡Œæµ‹è¯•
            result, err := service.Method(tt.input)

            // éªŒè¯ç»“æœ
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)

            // éªŒè¯ mock è°ƒç”¨
            mockDep.AssertExpectations(t)
        })
    }
}
```

## é”™è¯¯å¤„ç†æµ‹è¯•

### 1. ç¡®ä¿æ¯ä¸ª 'if err != nil' åˆ†æ”¯éƒ½æœ‰å¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹

```go
// è¢«æµ‹è¯•çš„å‡½æ•°
func ProcessData(input string) (string, error) {
    if input == "" {
        return "", errors.New("input cannot be empty") // â† éœ€è¦æµ‹è¯•ç”¨ä¾‹
    }

    result, err := externalCall(input)
    if err != nil {
        return "", fmt.Errorf("external call failed: %w", err) // â† éœ€è¦æµ‹è¯•ç”¨ä¾‹
    }

    return result, nil
}

// æµ‹è¯•ç”¨ä¾‹å¿…é¡»è¦†ç›–æ‰€æœ‰é”™è¯¯åˆ†æ”¯
tests := []struct {
    name          string
    input         string
    mockSetup     func()
    expectedError string
}{
    {
        name:          "empty_input_error",
        input:         "",
        expectedError: "input cannot be empty",
    },
    {
        name:  "external_call_error",
        input: "valid_input",
        mockSetup: func() {
            // è®¾ç½® mock è¿”å›é”™è¯¯
        },
        expectedError: "external call failed: mock error",
    },
    {
        name:  "success_case",
        input: "valid_input",
        mockSetup: func() {
            // è®¾ç½® mock è¿”å›æˆåŠŸ
        },
    },
}
```

## æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

### 1. æœ€ä½è¦†ç›–ç‡è¦æ±‚

- **ä¸šåŠ¡é€»è¾‘æ–‡ä»¶è‡³å°‘ 80% è¦†ç›–ç‡**
- **æ’é™¤ mock\_\*.go æ–‡ä»¶** - è¿™äº›æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ mock æ–‡ä»¶

### 2. è¦†ç›–ç‡æ£€æŸ¥å‘½ä»¤

```bash
# æ•´ä½“è¦†ç›–ç‡
go test -cover ./... -coverprofile=coverage.out

# ä»…ä¸šåŠ¡é€»è¾‘è¦†ç›–ç‡ï¼ˆæ’é™¤ mock æ–‡ä»¶ï¼‰
go test -cover ./... -coverprofile=coverage.out && go tool cover -func=coverage.out | grep -v mock_

# æ£€æŸ¥ç‰¹å®šä¸šåŠ¡é€»è¾‘æ–‡ä»¶
go tool cover -func=coverage.out | grep "\.go:" | grep -v mock_

# ç”Ÿæˆ HTML è¦†ç›–ç‡æŠ¥å‘Š
go tool cover -html=coverage.out
```

## é¡¹ç›®ç‰¹å®šè§„åˆ™

### 1. ä½¿ç”¨å®½æ¾çš„ SQL åŒ¹é…æ¨¡å¼

å¯¹äº SQL æµ‹è¯•ï¼Œä½¿ç”¨å®½æ¾çš„æ­£åˆ™è¡¨è¾¾å¼è€Œä¸æ˜¯ä¸¥æ ¼åŒ¹é…ï¼š

```go
// âœ… æ¨èï¼šå®½æ¾æ¨¡å¼
mock.ExpectQuery("SELECT.*FROM.*table").WillReturnRows(rows)

// âŒ é¿å…ï¼šè¿‡äºä¸¥æ ¼çš„åŒ¹é…
mock.ExpectQuery("SELECT id, name FROM table WHERE id = ?").WillReturnRows(rows)
```

### 2. éµå¾ª Given/When/Then æ¨¡å¼

```go
t.Run("test_case", func(t *testing.T) {
    t.Parallel()

    // Given: å‡†å¤‡æµ‹è¯•æ•°æ®å’Œ mock
    input := TestInput{Field: "value"}
    mockDep := NewMockDependency(t)
    mockDep.On("Method", mock.Anything).Return(expected, nil)

    // When: æ‰§è¡Œè¢«æµ‹è¯•çš„å‡½æ•°
    result, err := functionUnderTest(input, mockDep)

    // Then: éªŒè¯ç»“æœ
    require.NoError(t, err)
    assert.Equal(t, expected, result)
    mockDep.AssertExpectations(t)
})
```

### 3. æµ‹è¯•æ–‡ä»¶ç»„ç»‡

- æ¯ä¸ªæºæ–‡ä»¶å¯¹åº”ä¸€ä¸ªæµ‹è¯•æ–‡ä»¶
- æµ‹è¯•å‡½æ•°åç§°åº”è¯¥æ¸…æ™°æè¿°è¢«æµ‹è¯•çš„åŠŸèƒ½
- ä½¿ç”¨æè¿°æ€§çš„æµ‹è¯•ç”¨ä¾‹åç§°

## å¸¸è§é™·é˜±å’Œæœ€ä½³å®è·µ

### âŒ é¿å…çš„åšæ³•

- åœ¨ä¿®æ”¹å…¨å±€å˜é‡çš„æµ‹è¯•ä¸­ä½¿ç”¨ `t.Parallel()`
- åœ¨ä¿®æ”¹ç¯å¢ƒå˜é‡çš„æµ‹è¯•ä¸­ä½¿ç”¨ `t.Parallel()`
- å¿½ç•¥é”™è¯¯åˆ†æ”¯çš„æµ‹è¯•è¦†ç›–
- ä½¿ç”¨è¿‡äºä¸¥æ ¼çš„ SQL åŒ¹é…æ¨¡å¼
- å¿˜è®°æ¸…ç†æµ‹è¯•åçš„çŠ¶æ€

### âœ… æ¨èçš„åšæ³•

- å¯¹çº¯å‡½æ•°ä½¿ç”¨ `t.Parallel()` æé«˜æµ‹è¯•é€Ÿåº¦
- ä½¿ç”¨ `sync.Once` ä¿æŠ¤å…±äº«èµ„æºåˆå§‹åŒ–
- ä¸ºæ¯ä¸ªé”™è¯¯åˆ†æ”¯ç¼–å†™æµ‹è¯•ç”¨ä¾‹
- ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•æé«˜å¯ç»´æŠ¤æ€§
- åœ¨æµ‹è¯•åæ¢å¤å…¨å±€çŠ¶æ€
- ä½¿ç”¨ Given/When/Then æ¨¡å¼ç»„ç»‡æµ‹è¯•é€»è¾‘
