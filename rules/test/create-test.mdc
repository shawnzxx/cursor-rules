---
globs: *_test.go
alwaysApply: false
---

# å•å…ƒæµ‹è¯•åˆ›å»ºæŒ‡å—

æœ¬æ–‡æ¡£æä¾›äº†åœ¨ ${PROJECT_NAME} é¡¹ç›®ä¸­åˆ›å»ºé«˜è´¨é‡å•å…ƒæµ‹è¯•çš„å®Œæ•´æŒ‡å—ã€‚

## åŸºæœ¬æµ‹è¯•ç»“æ„

### 1. æµ‹è¯•æ–‡ä»¶å‘½å

- æµ‹è¯•æ–‡ä»¶å¿…é¡»ä»¥ `_test.go` ç»“å°¾
- ä¸è¢«æµ‹è¯•çš„æºæ–‡ä»¶åŒç›®å½•ï¼š`filename.go` -> `filename_test.go`

### 2. åŸºæœ¬æµ‹è¯•æ¨¡æ¿

```go
package packagename

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestFunctionName(t *testing.T) {
    t.Parallel() // ä½¿ç”¨ t.Parallel() å¦‚æœæµ‹è¯•ä¸ä¿®æ”¹å…¨å±€çŠ¶æ€

    tests := []struct {
        name           string
        input          InputType
        expectedOutput OutputType
        expectedError  string
    }{
        {
            name:           "success_case",
            input:          InputType{/* test data */},
            expectedOutput: OutputType{/* expected result */},
            expectedError:  "",
        },
        {
            name:          "error_case",
            input:         InputType{/* test data */},
            expectedError: "expected error message",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // ä½¿ç”¨ t.Parallel() å¦‚æœå­æµ‹è¯•ä¸ä¿®æ”¹å…¨å±€çŠ¶æ€

            // Given/When/Then æ¨¡å¼
            // Given: è®¾ç½®æµ‹è¯•æ•°æ®

            // When: æ‰§è¡Œè¢«æµ‹è¯•çš„å‡½æ•°
            result, err := FunctionName(tt.input)

            // Then: éªŒè¯ç»“æœ
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)
        })
    }
}
```

## æ–­è¨€é€‰æ‹©æŒ‡å— ğŸ¯

### åŸºæœ¬åŸåˆ™

- **æ–°æµ‹è¯•**ï¼šé»˜è®¤ä½¿ç”¨ `assert.*` ç³»åˆ—
- **ç°æœ‰æµ‹è¯•**ï¼šä¿æŒç°æœ‰çš„ `require.*` è°ƒç”¨ä¸å˜ï¼ˆé¿å…ä¸å¿…è¦çš„ä¿®æ”¹ï¼‰
- **é”™è¯¯æ£€æŸ¥**ï¼šå¯¹äºç‹¬ç«‹çš„é”™è¯¯æ£€æŸ¥ï¼Œä¼˜å…ˆä½¿ç”¨ `assert.NoError(t, err)` æˆ– `assert.EqualError(t, err, "expected message")`
- **CI/CD ç¯å¢ƒ**ï¼š`assert.*` å’Œ `require.*` éƒ½ä¼šåœ¨æµ‹è¯•å¤±è´¥æ—¶åœæ­¢ CI/CDï¼Œä½† `assert.*` æä¾›æ›´å¤šè¯Šæ–­ä¿¡æ¯

åœ¨ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç‰¹åˆ«æ˜¯åœ¨ **CI/CD ç¯å¢ƒ**ä¸­ï¼Œæ¨èä½¿ç”¨ `assert.*` ç³»åˆ—æ–­è¨€ï¼š

```go
func TestWallet(t *testing.T) {
    wallet := CreateWallet()

    // âœ… æ¨èï¼šä½¿ç”¨ assert - æ”¶é›†æ‰€æœ‰å¤±è´¥ä¿¡æ¯
    assert.NotNil(t, wallet)
    assert.Equal(t, 100, wallet.Balance)
    assert.Equal(t, "active", wallet.Status)
    assert.True(t, wallet.IsValid())
    // å³ä½¿å‰é¢çš„æ–­è¨€å¤±è´¥ï¼Œæ‰€æœ‰æ–­è¨€éƒ½ä¼šæ‰§è¡Œï¼Œæä¾›å®Œæ•´çš„é”™è¯¯ä¿¡æ¯
}
```

**ä¸ºä»€ä¹ˆæ¨è `assert`ï¼š**

- ğŸ“Š **æ›´å¥½çš„é”™è¯¯è¯Šæ–­**ï¼šæ”¶é›†æ‰€æœ‰å¤±è´¥ï¼Œä¸€æ¬¡çœ‹åˆ°æ‰€æœ‰é—®é¢˜
- ğŸš€ **æé«˜è°ƒè¯•æ•ˆç‡**ï¼šä¸€æ¬¡æ€§ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªä¸€ä¸ªæ¥
- âš¡ **CI/CD è¡Œä¸ºä¸€è‡´**ï¼šä»»ä½•å¤±è´¥éƒ½ä¼šå¯¼è‡´ `make test` è¿”å›éé›¶é€€å‡ºç ï¼Œåœæ­¢ CI/CD pipeline
- ğŸ” **å®Œæ•´çš„æµ‹è¯•æŠ¥å‘Š**ï¼šåœ¨ Jenkins æ—¥å¿—ä¸­èƒ½çœ‹åˆ°æ‰€æœ‰å¤±è´¥çš„æ–­è¨€

#### ä»…åœ¨ä¾èµ–åœºæ™¯ä½¿ç”¨ `require.*`

åªåœ¨**åç»­æ–­è¨€å¼ºçƒˆä¾èµ–å‰é¢ç»“æœ**æ—¶ä½¿ç”¨ `require.*`ï¼š

```go
func TestWalletOperations(t *testing.T) {
    wallet := CreateWallet()

    // âœ… åˆé€‚ä½¿ç”¨ requireï¼šå¦‚æœ wallet ä¸º nilï¼Œåç»­æ“ä½œéƒ½æ²¡æ„ä¹‰
    require.NotNil(t, wallet)

    // è¿™äº›æ–­è¨€ç›¸äº’ç‹¬ç«‹ï¼Œä½¿ç”¨ assert
    assert.Equal(t, 100, wallet.Balance)
    assert.Equal(t, "active", wallet.Status)
    assert.True(t, wallet.IsValid())

    // å¦ä¸€ä¸ªä¾èµ–åœºæ™¯
    err := wallet.Debit(50)
    require.NoError(t, err) // å¦‚æœè¿™é‡Œå¤±è´¥ï¼Œåç»­ä½™é¢æ£€æŸ¥æ²¡æ„ä¹‰

    assert.Equal(t, 50, wallet.Balance)
}
```

#### å¯¹æ¯”ç¤ºä¾‹

```go
// âŒ ä½¿ç”¨ require - åªçœ‹åˆ°ç¬¬ä¸€ä¸ªé—®é¢˜
func TestWalletWithRequire(t *testing.T) {
    wallet := CreateWallet()
    require.NotNil(t, wallet)        // å¦‚æœå¤±è´¥ï¼Œæµ‹è¯•åœæ­¢
    require.Equal(t, 100, wallet.Balance)    // ä¸ä¼šæ‰§è¡Œ
    require.Equal(t, "active", wallet.Status) // ä¸ä¼šæ‰§è¡Œ
    require.True(t, wallet.IsValid())        // ä¸ä¼šæ‰§è¡Œ
    // ç»“æœï¼šåªçŸ¥é“ç¬¬ä¸€ä¸ªé”™è¯¯ï¼Œéœ€è¦å¤šæ¬¡ä¿®å¤-æµ‹è¯•å¾ªç¯
}

// âœ… ä½¿ç”¨ assert - çœ‹åˆ°æ‰€æœ‰é—®é¢˜
func TestWalletWithAssert(t *testing.T) {
    wallet := CreateWallet()
    assert.NotNil(t, wallet)         // å¤±è´¥ä½†ç»§ç»­
    assert.Equal(t, 100, wallet.Balance)     // ä¹Ÿä¼šæ£€æŸ¥
    assert.Equal(t, "active", wallet.Status) // ä¹Ÿä¼šæ£€æŸ¥
    assert.True(t, wallet.IsValid())         // ä¹Ÿä¼šæ£€æŸ¥
    // ç»“æœï¼šä¸€æ¬¡çœ‹åˆ°æ‰€æœ‰é”™è¯¯ï¼Œä¸€æ¬¡æ€§ä¿®å¤æ‰€æœ‰é—®é¢˜
}
```

## æµ‹è¯•ç”¨ä¾‹è§„èŒƒ

### 1. å¯¹äºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€çš„æµ‹è¯•

**æ·»åŠ  `t.Parallel()` ä»¥æé«˜æµ‹è¯•æ‰§è¡Œé€Ÿåº¦**

```go
func TestPureFunction(t *testing.T) {
    t.Parallel() // âœ… å®‰å…¨ï¼Œå› ä¸ºä¸ä¿®æ”¹å…¨å±€çŠ¶æ€

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel() // âœ… å­æµ‹è¯•ä¹Ÿå¯ä»¥å¹¶è¡Œ

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

### 2. å¯¹äºä¿®æ”¹å…¨å±€å˜é‡çš„æµ‹è¯•

**ä¸ä½¿ç”¨ `t.Parallel()` ä»¥é¿å…ç«æ€æ¡ä»¶**

```go
var globalVar = "initial"

func TestFunctionModifyingGlobal(t *testing.T) {
    // âŒ ä¸ä½¿ç”¨ t.Parallel() - ä¿®æ”¹å…¨å±€å˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // âŒ å­æµ‹è¯•ä¹Ÿä¸ä½¿ç”¨ t.Parallel()
            // ä¸ä½¿ç”¨ t.Parallel() å› ä¸ºä¿®æ”¹å…¨å±€å˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

            // ä¿å­˜åŸå§‹å€¼
            original := globalVar
            defer func() {
                globalVar = original // æ¢å¤åŸå§‹å€¼
            }()

            // ä¿®æ”¹å…¨å±€å˜é‡è¿›è¡Œæµ‹è¯•
            globalVar = tt.testValue

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

### 3. å¯¹äºå…±äº«èµ„æºåˆå§‹åŒ–

**ä½¿ç”¨ `sync.Once` ç¡®ä¿çº¿ç¨‹å®‰å…¨çš„å•æ¬¡åˆå§‹åŒ–**

```go
import "sync"

var (
    sharedResource *SomeResource
    once          sync.Once
)

func initializeSharedResource() {
    once.Do(func() {
        sharedResource = &SomeResource{
            // åˆå§‹åŒ–é€»è¾‘
        }
    })
}

func TestWithSharedResource(t *testing.T) {
    t.Parallel() // âœ… å®‰å…¨ï¼Œå› ä¸ºä½¿ç”¨äº† sync.Once ä¿æŠ¤

    initializeSharedResource()
    // ä½¿ç”¨ sharedResource è¿›è¡Œæµ‹è¯•
}
```

### 4. å¯¹äºç¯å¢ƒå˜é‡ä¿®æ”¹

**ä¸ä½¿ç”¨ `t.Parallel()` å¹¶æ·»åŠ é€‚å½“çš„æ¸…ç†æœºåˆ¶**

```go
func TestWithEnvironmentVariable(t *testing.T) {
    // âŒ ä¸ä½¿ç”¨ t.Parallel() - ä¿®æ”¹ç¯å¢ƒå˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // âŒ ä¸ä½¿ç”¨ t.Parallel() å› ä¸ºä¿®æ”¹ç¯å¢ƒå˜é‡ä¼šäº§ç”Ÿç«æ€æ¡ä»¶

            // ä¿å­˜åŸå§‹ç¯å¢ƒå˜é‡
            originalEnv := os.Getenv("TEST_ENV")
            defer func() {
                if originalEnv == "" {
                    os.Unsetenv("TEST_ENV")
                } else {
                    os.Setenv("TEST_ENV", originalEnv)
                }
            }()

            // è®¾ç½®æµ‹è¯•ç¯å¢ƒå˜é‡
            err := os.Setenv("TEST_ENV", tt.envValue)
            require.NoError(t, err)

            // æµ‹è¯•é€»è¾‘...
        })
    }
}
```

## æµ‹è¯•æ•°æ®å‡†å¤‡

### 1. ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•

```go
tests := []struct {
    name           string
    input          InputType
    mockSetup      func(*MockDependency)
    expectedOutput OutputType
    expectedError  string
}{
    {
        name: "success_case",
        input: InputType{
            Field1: "value1",
            Field2: 123,
        },
        mockSetup: func(mock *MockDependency) {
            mock.On("Method", mock.Anything).Return(expectedResult, nil)
        },
        expectedOutput: OutputType{
            Field: "expected",
        },
    },
}
```

### 2. Mock è®¾ç½®

```go
func TestWithMocks(t *testing.T) {
    t.Parallel()

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()

            // åˆ›å»º mock
            mockDep := NewMockDependency(t)

            // è®¾ç½® mock æœŸæœ›
            if tt.mockSetup != nil {
                tt.mockSetup(mockDep)
            }

            // åˆ›å»ºè¢«æµ‹è¯•å¯¹è±¡
            service := NewService(mockDep)

            // æ‰§è¡Œæµ‹è¯•
            result, err := service.Method(tt.input)

            // éªŒè¯ç»“æœ
            if tt.expectedError != "" {
                assert.EqualError(t, err, tt.expectedError)
                return
            }

            assert.NoError(t, err)
            assert.Equal(t, tt.expectedOutput, result)

            // éªŒè¯ mock è°ƒç”¨
            mockDep.AssertExpectations(t)
        })
    }
}
```

## é”™è¯¯å¤„ç†æµ‹è¯•

### 1. ç¡®ä¿æ¯ä¸ª 'if err != nil' åˆ†æ”¯éƒ½æœ‰å¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹

```go
// è¢«æµ‹è¯•çš„å‡½æ•°
func ProcessData(input string) (string, error) {
    if input == "" {
        return "", errors.New("input cannot be empty") // â† éœ€è¦æµ‹è¯•ç”¨ä¾‹
    }

    result, err := externalCall(input)
    if err != nil {
        return "", fmt.Errorf("external call failed: %w", err) // â† éœ€è¦æµ‹è¯•ç”¨ä¾‹
    }

    return result, nil
}

// æµ‹è¯•ç”¨ä¾‹å¿…é¡»è¦†ç›–æ‰€æœ‰é”™è¯¯åˆ†æ”¯
tests := []struct {
    name          string
    input         string
    mockSetup     func()
    expectedError string
}{
    {
        name:          "empty_input_error",
        input:         "",
        expectedError: "input cannot be empty",
    },
    {
        name:  "external_call_error",
        input: "valid_input",
        mockSetup: func() {
            // è®¾ç½® mock è¿”å›é”™è¯¯
        },
        expectedError: "external call failed: mock error",
    },
    {
        name:  "success_case",
        input: "valid_input",
        mockSetup: func() {
            // è®¾ç½® mock è¿”å›æˆåŠŸ
        },
    },
}
```

## æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

### 1. æœ€ä½è¦†ç›–ç‡è¦æ±‚

- **ä¸šåŠ¡é€»è¾‘æ–‡ä»¶è‡³å°‘ 80% è¦†ç›–ç‡**
- **æ’é™¤ mock\_\*.go æ–‡ä»¶** - è¿™äº›æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ mock æ–‡ä»¶

### 2. è¦†ç›–ç‡æ£€æŸ¥å‘½ä»¤

```bash
# æ•´ä½“è¦†ç›–ç‡
go test -cover ./... -coverprofile=coverage.out

# ä»…ä¸šåŠ¡é€»è¾‘è¦†ç›–ç‡ï¼ˆæ’é™¤ mock æ–‡ä»¶ï¼‰
go test -cover ./... -coverprofile=coverage.out && go tool cover -func=coverage.out | grep -v mock_

# æ£€æŸ¥ç‰¹å®šä¸šåŠ¡é€»è¾‘æ–‡ä»¶
go tool cover -func=coverage.out | grep "\.go:" | grep -v mock_

# ç”Ÿæˆ HTML è¦†ç›–ç‡æŠ¥å‘Š
go tool cover -html=coverage.out
```

## é¡¹ç›®ç‰¹å®šè§„åˆ™

### 1. ä½¿ç”¨å®½æ¾çš„ SQL åŒ¹é…æ¨¡å¼

å¯¹äº SQL æµ‹è¯•ï¼Œä½¿ç”¨å®½æ¾çš„æ­£åˆ™è¡¨è¾¾å¼è€Œä¸æ˜¯ä¸¥æ ¼åŒ¹é…ï¼š

```go
// âœ… æ¨èï¼šå®½æ¾æ¨¡å¼
mock.ExpectQuery("SELECT.*FROM.*table").WillReturnRows(rows)

// âŒ é¿å…ï¼šè¿‡äºä¸¥æ ¼çš„åŒ¹é…
mock.ExpectQuery("SELECT id, name FROM table WHERE id = ?").WillReturnRows(rows)
```

### 2. éµå¾ª Given/When/Then æ¨¡å¼

```go
t.Run("test_case", func(t *testing.T) {
    t.Parallel()

    // Given: å‡†å¤‡æµ‹è¯•æ•°æ®å’Œ mock
    input := TestInput{Field: "value"}
    mockDep := NewMockDependency(t)
    mockDep.On("Method", mock.Anything).Return(expected, nil)

    // When: æ‰§è¡Œè¢«æµ‹è¯•çš„å‡½æ•°
    result, err := functionUnderTest(input, mockDep)

    // Then: éªŒè¯ç»“æœ
    require.NoError(t, err)
    assert.Equal(t, expected, result)
    mockDep.AssertExpectations(t)
})
```

### 3. æµ‹è¯•æ–‡ä»¶ç»„ç»‡

- æ¯ä¸ªæºæ–‡ä»¶å¯¹åº”ä¸€ä¸ªæµ‹è¯•æ–‡ä»¶
- æµ‹è¯•å‡½æ•°åç§°åº”è¯¥æ¸…æ™°æè¿°è¢«æµ‹è¯•çš„åŠŸèƒ½
- ä½¿ç”¨æè¿°æ€§çš„æµ‹è¯•ç”¨ä¾‹åç§°

### Interface Nil å¤„ç†æ–¹å¼

#### é—®é¢˜ï¼šGo Interface çš„ nil é™·é˜±

å½“å°† `nil` å…·ä½“ç±»å‹æŒ‡é’ˆä¼ é€’ç»™æ¥å£å‚æ•°æ—¶ï¼Œæ¥å£ä¸ä¼šæ˜¯ `nil`ã€‚è¿™ä¼šå¯¼è‡´ `interface == nil` æ£€æŸ¥å¤±è´¥ã€‚

#### é”™è¯¯ç¤ºä¾‹

```go
func TestWithNilInterface_Wrong(t *testing.T) {
    var mockCacher *MockCacher = nil  // nil å…·ä½“ç±»å‹

    // âŒ é”™è¯¯ï¼šä¼ é€’ nil å…·ä½“ç±»å‹ç»™æ¥å£å‚æ•°
    business := NewBusiness(storer, mockCacher)

    // è¿™ä¼šå¤±è´¥ï¼Œå› ä¸º business.cacher != nil
    // (æ¥å£åŒ…å« nil *MockCacherï¼Œä¸æ˜¯ nil æ¥å£)
    result, err := business.RefreshCache(ctx)
}
```

#### âœ… æ­£ç¡®å¤„ç†æ–¹æ³•

```go
func TestWithNilInterface_Correct(t *testing.T) {
    var mockCacher *MockCacher = nil

    // âœ… æ­£ç¡®ï¼šæ˜¾å¼åˆ›å»º nil æ¥å£
    var cacherInterface Cacher  // nil æ¥å£
    if mockCacher != nil {
        cacherInterface = mockCacher
    }

    business := NewBusiness(storer, cacherInterface)

    // ç°åœ¨ business.cacher == nil æ£€æŸ¥ä¼šæ­£ç¡®å·¥ä½œ
    result, err := business.RefreshCache(ctx)
}
```

#### å®é™…æ¡ˆä¾‹ï¼šRefreshCache æµ‹è¯•ä¿®å¤

```go
// ä¿®å¤å‰çš„é”™è¯¯æµ‹è¯•
for name, tc := range tcs {
    t.Run(name, func(t *testing.T) {
        mockStorer := &MockStorer{}
        var mockCacher *MockCacher

        if name == "no_cacher_configured" {
            mockCacher = nil  // âŒ è¿™æ˜¯ nil å…·ä½“ç±»å‹ï¼Œä¸æ˜¯ nil æ¥å£
        } else {
            mockCacher = &MockCacher{}
        }

        // âŒ é”™è¯¯ï¼šä¼ é€’å¯èƒ½æ˜¯ nil å…·ä½“ç±»å‹çš„å€¼ç»™æ¥å£å‚æ•°
        business := NewBusiness(mockStorer, mockCacher)
    })
}

// ä¿®å¤åçš„æ­£ç¡®æµ‹è¯•
for name, tc := range tcs {
    t.Run(name, func(t *testing.T) {
        mockStorer := &MockStorer{}
        var mockCacher *MockCacher

        if name == "no_cacher_configured" {
            mockCacher = nil
        } else {
            mockCacher = &MockCacher{}
        }

        tc.mockSetup(mockStorer, mockCacher)

        // âœ… æ­£ç¡®ï¼šæ˜¾å¼å¤„ç† nil æ¥å£
        var cacherInterface Cacher
        if mockCacher != nil {
            cacherInterface = mockCacher
        }
        // å¦‚æœ mockCacher æ˜¯ nilï¼ŒcacherInterface ä¿æŒ nil æ¥å£

        business := NewBusiness(mockStorer, cacherInterface)
    })
}
```

#### å…³é”®åŸç†

åœ¨ Go ä¸­ï¼Œæ¥å£åªæœ‰åœ¨**ç±»å‹å’Œå€¼éƒ½ä¸º nil** æ—¶æ‰ä¸º `nil`ï¼š

```go
var i interface{} = (*MyType)(nil)  // æ¥å£ä¸ä¸º nilï¼
fmt.Println(i == nil)               // false

var i interface{} = nil             // æ¥å£ä¸º nil
fmt.Println(i == nil)               // true
```

### æœ€ä½³å®è·µ

1. **æ˜ç¡®åŒºåˆ† nil å…·ä½“ç±»å‹å’Œ nil æ¥å£**
2. **æµ‹è¯•ä¸­éœ€è¦ nil æ¥å£æ—¶ï¼Œæ˜¾å¼å¤„ç†è½¬æ¢**
3. **é¿å…ç›´æ¥å°†å¯èƒ½ä¸º nil çš„å…·ä½“ç±»å‹å˜é‡ä¼ é€’ç»™æ¥å£å‚æ•°**

## å¸¸è§é™·é˜±å’Œæœ€ä½³å®è·µ

### âŒ é¿å…çš„åšæ³•

- åœ¨ä¿®æ”¹å…¨å±€å˜é‡çš„æµ‹è¯•ä¸­ä½¿ç”¨ `t.Parallel()`
- åœ¨ä¿®æ”¹ç¯å¢ƒå˜é‡çš„æµ‹è¯•ä¸­ä½¿ç”¨ `t.Parallel()`
- å¿½ç•¥é”™è¯¯åˆ†æ”¯çš„æµ‹è¯•è¦†ç›–
- ä½¿ç”¨è¿‡äºä¸¥æ ¼çš„ SQL åŒ¹é…æ¨¡å¼
- å¿˜è®°æ¸…ç†æµ‹è¯•åçš„çŠ¶æ€
- **ç›´æ¥å°† nil å…·ä½“ç±»å‹ä¼ é€’ç»™æ¥å£å‚æ•°**

### âœ… æ¨èçš„åšæ³•

- å¯¹çº¯å‡½æ•°ä½¿ç”¨ `t.Parallel()` æé«˜æµ‹è¯•é€Ÿåº¦
- ä½¿ç”¨ `sync.Once` ä¿æŠ¤å…±äº«èµ„æºåˆå§‹åŒ–
- ä¸ºæ¯ä¸ªé”™è¯¯åˆ†æ”¯ç¼–å†™æµ‹è¯•ç”¨ä¾‹
- ä½¿ç”¨è¡¨é©±åŠ¨æµ‹è¯•æé«˜å¯ç»´æŠ¤æ€§
- åœ¨æµ‹è¯•åæ¢å¤å…¨å±€çŠ¶æ€
- ä½¿ç”¨ Given/When/Then æ¨¡å¼ç»„ç»‡æµ‹è¯•é€»è¾‘
- **æ­£ç¡®å¤„ç†æ¥å£çš„ nil å€¼è½¬æ¢**
