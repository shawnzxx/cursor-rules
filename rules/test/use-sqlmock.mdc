# 使用 sqlmock 的 AI 专用规则

## 1. 必须遵循的核心要点（务必全部记住）

- **每个测试用例都要独立初始化 `sqlmock.New()`，并在 defer 里 `db.Close()` + `mock.ExpectationsWereMet()`。**
- **所有 SQL 匹配必须用“宽松正则”，如 `SELECT.*FROM.*table`，不要用全等或复杂正则。**
- **每个 SQL 期望（ExpectQuery/ExpectExec）要紧跟实际操作前设置，不能提前批量设置。**
- **参数匹配要用原始类型，动态时间戳/JSON 等用 `sqlmock.AnyArg()`。**
- **事务相关要严格按 Begin/Commit/Rollback 顺序设置期望。**
- **测试用例要覆盖成功和失败（如 DB error）两种分支。**
- **所有 mock 期望都要被满足，否则测试必须 fail。**

## 2. 参考测试样本

- 可以参考测试样本：api/internal/business/domain/pointsbus/pointsdb/pointsdb_test.go

## 3. 推荐测试结构

```go
func TestXXX(t *testing.T) {
    t.Parallel()

    db, mock, err := sqlmock.New()
    require.NoError(t, err)
    defer func() {
        mock.ExpectClose()
        err = db.Close()
        require.NoError(t, err)
        require.NoError(t, mock.ExpectationsWereMet())
    }()

    // 1. 设置 SQL 期望
    mock.ExpectQuery("SELECT.*FROM.*points").
        WithArgs(123).
        WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))

    // 2. 调用被测方法
    result, err := store.Query(ctx, ...)

    // 3. 断言
    require.NoError(t, err)
    assert.Equal(t, 1, result.ID)
}
```

### 重要：db.Close() 错误处理规则

**必须检查 `db.Close()` 的返回值，避免 linting 错误：**

```go
// ❌ 错误：没有检查 db.Close() 的返回值
defer func() {
    mock.ExpectClose()
    db.Close() // 这会导致 errcheck linting 错误
    require.NoError(t, mock.ExpectationsWereMet())
}()

// ✅ 正确：检查 db.Close() 的返回值
defer func() {
    mock.ExpectClose()
    err = db.Close()
    require.NoError(t, err)
    require.NoError(t, mock.ExpectationsWereMet())
}()
```

**关键要点：**

- `db.Close()` 可能返回错误，必须检查
- 使用 `err = db.Close()` 然后 `require.NoError(t, err)`
- 这样可以避免 `errcheck` linting 错误
- 同时确保数据库连接正确关闭
- **对于多个数据库连接（如 db 和 tx），每个都要单独处理**

**多连接示例：**

```go
// 当测试中有多个数据库连接时
func TestStore_NewWithTx(t *testing.T) {
    t.Parallel()

    // Given
    db, mock, err := sqlmock.New()
    require.NoError(t, err)
    defer func() {
        mock.ExpectClose()
        err = db.Close()
        require.NoError(t, err)
        require.NoError(t, mock.ExpectationsWereMet())
    }()

    store := New(db)
    tx, txMock, err := sqlmock.New()
    require.NoError(t, err)
    defer func() {
        txMock.ExpectClose()
        err = tx.Close()
        require.NoError(t, err)
        require.NoError(t, txMock.ExpectationsWereMet())
    }()

    // When & Then
    newStore := store.NewWithTx(tx)
    require.NotNil(t, newStore)
}
```

## 4. 常见错误（务必避免）

- 不要用精确 SQL 字符串或复杂正则。
- 不要提前批量设置所有 SQL 期望。
- 不要忘记 defer 检查 `ExpectationsWereMet()`。
- 不要遗漏事务相关的 Begin/Commit/Rollback 期望。
- 不要用错误类型的参数（如 int64/float64 混用）。
- **不要忘记检查 `db.Close()` 的返回值，会导致 errcheck linting 错误。**
- **不要忘记为每个数据库连接（db、tx 等）单独设置 `ExpectClose()` 期望。**
- **不要忘记检查每个 `Close()` 调用的返回值。**

## 5. 只保留最常用的例子

- 查询：`mock.ExpectQuery("SELECT.*FROM.*table").WithArgs(...).WillReturnRows(...)`
- 插入：`mock.ExpectQuery("INSERT.*INTO.*table.*VALUES.*").WithArgs(...).WillReturnRows(...)`
- 更新/删除：`mock.ExpectExec("UPDATE.*table.*SET.*").WithArgs(...).WillReturnResult(...)`
- 事务：`mock.ExpectBegin()`、`mock.ExpectCommit()`、`mock.ExpectRollback()`

## 5.1. 宽松 SQL 匹配模式（AI 必须遵循）

### 核心原则：使用最宽松的正则表达式匹配

**❌ 错误：过于严格的 SQL 匹配**

```go
// 过于严格，容易失败
mock.ExpectQuery("SELECT \"incoming_events\".* FROM \"incoming_events\" WHERE (\"incoming_events\".\"key\" = $1) AND (\"incoming_events\".\"event_id\" = $2) ORDER BY id desc;").
    WithArgs("test-key", "test-event-id").
    WillReturnRows(rows)
```

**✅ 正确：宽松的 SQL 匹配**

```go
// 宽松匹配，更稳定
mock.ExpectQuery("SELECT.*FROM.*incoming_events.*WHERE.*key.*=.*AND.*event_id.*=.*ORDER BY.*id.*desc.*").
    WithArgs("test-key", "test-event-id").
    WillReturnRows(rows)
```

### 推荐的 SQL 匹配模式

1. **基础查询模式**

   ```go
   // 简单查询
   mock.ExpectQuery("SELECT.*FROM.*table.*WHERE.*field.*=.*")

   // 复杂查询（带排序、分页）
   mock.ExpectQuery("SELECT.*FROM.*table.*WHERE.*field.*=.*ORDER BY.*LIMIT.*OFFSET.*")
   ```

2. **插入模式**

   ```go
   // INSERT 操作
   mock.ExpectExec("INSERT.*INTO.*table.*VALUES.*")

   // 或者更宽松的
   mock.ExpectExec("INSERT.*INTO.*table.*")
   ```

3. **更新模式**

   ```go
   // UPDATE 操作
   mock.ExpectExec("UPDATE.*table.*SET.*WHERE.*id.*=.*")
   ```

4. **删除模式**
   ```go
   // DELETE 操作
   mock.ExpectExec("DELETE.*FROM.*table.*WHERE.*id.*=.*")
   ```

### 参数匹配策略

**动态值使用 `sqlmock.AnyArg()`：**

```go
mock.ExpectExec("INSERT.*INTO.*table.*VALUES.*").
    WithArgs(
        sqlmock.AnyArg(), // ID (snowflake)
        "fixed-value",    // 固定值
        sqlmock.AnyArg(), // 时间戳
        sqlmock.AnyArg(), // JSON 数据
    ).
    WillReturnResult(sqlmock.NewResult(1, 1))
```

**固定值使用实际值：**

```go
mock.ExpectQuery("SELECT.*FROM.*table.*WHERE.*key.*=.*").
    WithArgs("test-key").  // 固定值
    WillReturnRows(rows)
```

## 5.2. 简化断言检查（AI 必须遵循）

### 核心原则：只检查关键字段，避免过度断言

**❌ 错误：过度详细的断言**

```go
// 过于详细，容易因无关字段变化而失败
require.Equal(t, int64(123), result[0].ID)
require.Equal(t, "test-topic", result[0].Topic)
require.Equal(t, "test-key", result[0].Key)
require.Equal(t, "test-event-id", result[0].EventID)
require.Equal(t, "test-consumer-group", result[0].ConsumerGroup)
require.Equal(t, []byte("test-payload"), result[0].Payload)
require.Equal(t, map[string]string{"header1": "value1"}, result[0].Headers)
require.Equal(t, time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC), result[0].CreatedAt)
require.Equal(t, time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC), result[0].UpdatedAt)
```

**✅ 移除了对 Payload 和 Headers 字段的严格检查，只保留了关键字段的验证**

```go
// 只检查关键业务字段
require.NoError(t, err)
require.Len(t, result, 1)
require.Equal(t, int64(123), result[0].ID)
require.Equal(t, "test-topic", result[0].Topic)
require.Equal(t, "test-key", result[0].Key)
require.Equal(t, "test-event-id", result[0].EventID)
require.Equal(t, "test-consumer-group", result[0].ConsumerGroup)
```

### 推荐的断言策略

1. **基础检查**

   ```go
   require.NoError(t, err)
   require.Len(t, result, expectedLength)
   ```

2. **关键字段检查**

   ```go
   // 只检查核心业务字段
   require.Equal(t, expectedID, result.ID)
   require.Equal(t, expectedName, result.Name)
   require.Equal(t, expectedStatus, result.Status)
   ```

3. **错误检查**

   ```go
   require.Error(t, err)
   require.Contains(t, err.Error(), "expected error message")
   ```

4. **类型检查**
   ```go
   require.NotNil(t, result)
   require.IsType(t, &ExpectedType{}, result)
   ```

### 避免检查的字段

- **时间戳字段**：`CreatedAt`, `UpdatedAt`（除非业务逻辑依赖）
- **复杂数据结构**：`Headers`, `Meta`, `Config`（除非核心业务）
- **自动生成字段**：`ID`（如果使用 snowflake 等）
- **内部状态字段**：`Version`, `Status`（除非测试状态转换）

### 参考测试样本

可以参考以下测试文件了解宽松匹配和简化断言的最佳实践：

- `api/internal/business/domain/tierbus/tierdb/tierdb_test.go`
- `api/internal/business/domain/pointsbus/pointsdb/pointsdb_test.go`

---

## 6. 错误分支覆盖规则（AI 必须遵守）

### 必须测试的错误分支类型：

1. **数据转换错误**

   ```go
   // 测试 toTxnDB 转换失败
   input: txnbus.Transaction{
       Meta: createUnencodableObject(), // 无法 JSON 编码
   }
   expectedError: "encoder.JSON failed"
   ```

2. **参数验证错误**

   ```go
   // 测试 order.ToSQLBoilerQMs 参数无效
   ctx := order.SetInCtx(ctx, order.New(order.By{
       Name: "invalid_field", // 不在 allowedKeys 中
   }))
   expectedError: "By key not allowed"
   ```

3. **类型转换错误**

   ```go
   // 测试 enum 字符串解析失败
   mock.ExpectQuery("SELECT.*FROM.*table").
       WillReturnRows(sqlmock.NewRows([]string{"type"}).AddRow("INVALID_TYPE"))
   expectedError: "invalid type"
   ```

4. **空值处理错误**

   ```go
   // 测试 nil 指针处理
   input: SomeStruct{
       RequiredField: nil, // 必填字段为空
   }
   expectedError: "required field is nil"
   ```

5. **数据库约束违反错误**

   ```go
   // 测试唯一约束违反 (UniqueViolation)
   // 必须使用正确的 PostgreSQL 错误类型
   import "github.com/jackc/pgx/v5/pgconn"

   mock.ExpectExec("INSERT INTO.*table.*VALUES.*").
       WithArgs(...).
       WillReturnError(&pgconn.PgError{
           Code:    "23505", // PostgreSQL 唯一约束违反错误码
           Message: "duplicate key value violates unique constraint",
       })

   // 验证错误处理逻辑
   require.Error(t, err)
   require.Contains(t, err.Error(), "duplicate event_id: 456")
   ```

6. **自定义错误类型检查**

   ```go
   // 测试 dberr.UniqueViolation.Is(err) 逻辑
   // 错误必须是 *pgconn.PgError 类型才能被正确识别
   mock.ExpectExec("INSERT INTO.*table.*VALUES.*").
       WillReturnError(&pgconn.PgError{
           Code:    "23505",
           Message: "duplicate key value violates unique constraint",
       })

   // 这会触发 if dberr.UniqueViolation.Is(err) 分支
   result, err := store.Create(ctx, audit)
   require.Error(t, err)
   require.Contains(t, err.Error(), "duplicate event_id: 456")
   ```

### 错误分支测试检查清单：

- [ ] **每个 `if err != nil` 分支都要有对应的测试用例**
- [ ] **数据转换函数（如 `toTxnDB`）要有失败测试**
- [ ] **参数验证函数要有无效参数测试**
- [ ] **JSON 序列化/反序列化要有错误测试**
- [ ] **enum 解析要有无效值测试**
- [ ] **空值处理要有 nil 指针测试**
- [ ] **数据库操作要有连接错误测试**
- [ ] **数据库约束违反错误要有正确的错误类型测试**
- [ ] **自定义错误检查逻辑（如 `dberr.UniqueViolation.Is(err)`）要有对应的错误类型测试**

---

**特别强调：只要严格仿照 ./api/internal/business/domain/pointsbus/pointsdb/pointsdb_test.go 的结构和风格，基本不会出错！**

**额外强调：每个 `if err != nil` 都必须有对应的错误测试用例！**

**重要提醒：测试自定义错误检查逻辑时，必须使用正确的错误类型！**

```go
// ❌ 错误：使用字符串错误，dberr.UniqueViolation.Is(err) 会返回 false
mock.ExpectExec("INSERT INTO.*table.*VALUES.*").
    WillReturnError(errors.New("23505: duplicate key value violates unique constraint"))

// ✅ 正确：使用 *pgconn.PgError 类型，dberr.UniqueViolation.Is(err) 会返回 true
mock.ExpectExec("INSERT INTO.*table.*VALUES.*").
    WillReturnError(&pgconn.PgError{
        Code:    "23505",
        Message: "duplicate key value violates unique constraint",
    })
```

**关键点：**

- `dberr.UniqueViolation.Is(err)` 检查错误是否为 `*pgconn.PgError` 类型
- 只有正确的错误类型才能触发 `if dberr.UniqueViolation.Is(err)` 分支
- 使用错误的错误类型会导致测试覆盖率不完整

## 7. 最后也是最重要的

- 输出的代码和注释一定要用英文
